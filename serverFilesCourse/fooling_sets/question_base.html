<pl-question-panel>
<markdown>
Construct a fooling set to prove that the following language is not regular:

*{{{params.language_description}}}*

<hidden-hints></hidden-hints>

#### Instructions

Given a positive integer $i$, `getFoolingSetElement(i)` should return the $i^\text{th}$ element of your fooling set. (Note that sets are not ordered, but in order for the autograder to work, you should assign an order to the elements in your fooling set.)

To prove that your construction is correct, you must show that there exists a distinguishing suffix for all pairs of distinct elements in your fooling set. Given two positive integers $i$ and $j$, subject to $i < j$, let $x$ be the $i^\text{th}$ element of your fooling set, and let $y$ be the $j^\text{th}$ element of your fooling set. Then, `getDistinguishingSuffix(i, j)` should return a string $z$ such that either
* $xz \in L$ and $yz \notin L$, or
* $xz \notin L$ and $yz \in L$.

##### Helpful Tips
In Python, string exponentiation can be achieved with the `*` operator, and string concatenation can be achieved with the `+` operation. For example, $0^n1^n$ could be concisely expressed as `'0' * n + '1' * n`; there's no need to use a for loop to construct this string. 
</markdown>

<pl-file-editor
    file-name="user_code.py"
    ace-mode="ace/mode/python">
def getFoolingSetElement(i):
    return ''

def getDistinguishingSuffix(i, j):
    return ''
</pl-file-editor>
</pl-question-panel>

<pl-submission-panel>
    <pl-external-grader-results></pl-external-grader-results>
    <pl-file-preview></pl-file-preview>
</pl-submission-panel>
